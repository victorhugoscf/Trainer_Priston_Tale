unit Unit1;

interface

uses
  Winapi.Windows, Winapi.Messages, Winapi.TlHelp32, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,
  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, Vcl.StdCtrls;

type
  TForm1 = class(TForm)
    EditPID: TEdit;
    BtnAttach: TButton;
    EditValue1: TEdit;
    BtnApply: TButton;
    ProcessListBox: TListBox; // Alterado para TListBox
    Label1: TLabel;
    Label2: TLabel;
    EditValue2: TEdit;
    Label3: TLabel;
    EditValue3: TEdit;
    Label4: TLabel;
    EditValue4: TEdit;
    procedure FormCreate(Sender: TObject);
    procedure ProcessListBoxClick(Sender: TObject);
    procedure BtnAttachClick(Sender: TObject);
    procedure BtnApplyClick(Sender: TObject);
  private
    { Private declarations }
    FProcessHandle: THandle;
    procedure ListProcesses;
    function OpenProcessByPID(PID: DWORD): THandle;
    procedure WriteMemory(Address: Pointer; const Buffer: TBytes);
  public
    { Public declarations }
  end;

var
  Form1: TForm1;

implementation

{$R *.dfm}

procedure TForm1.FormCreate(Sender: TObject);
begin
  ListProcesses;
end;

procedure TForm1.ListProcesses;
var
  ProcessList: TStringList;
  Snapshot: THandle;
  ProcessEntry: TProcessEntry32;
begin
  ProcessList := TStringList.Create;
  try
    Snapshot := CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if Snapshot = INVALID_HANDLE_VALUE then Exit;

    ProcessEntry.dwSize := SizeOf(ProcessEntry);
    if Process32First(Snapshot, ProcessEntry) then
    begin
      repeat
        ProcessList.Add(Format('%d: %s', [ProcessEntry.th32ProcessID, ProcessEntry.szExeFile]));
      until not Process32Next(Snapshot, ProcessEntry);
    end;
    CloseHandle(Snapshot);

    ProcessListBox.Items.Assign(ProcessList);
  finally
    ProcessList.Free;
  end;
end;

procedure TForm1.ProcessListBoxClick(Sender: TObject);
begin
  if ProcessListBox.ItemIndex >= 0 then
  begin
    EditPID.Text := Copy(ProcessListBox.Items[ProcessListBox.ItemIndex], 1, Pos(':', ProcessListBox.Items[ProcessListBox.ItemIndex]) - 1);
  end;
end;

procedure TForm1.BtnAttachClick(Sender: TObject);
var
  PID: DWORD;
begin
  if TryStrToInt(EditPID.Text, Integer(PID)) then
  begin
    FProcessHandle := OpenProcessByPID(PID);
    if FProcessHandle = 0 then
      ShowMessage('Failed to attach to process.')
    else
      ShowMessage('Attached to process.');
  end
  else
    ShowMessage('Invalid PID.');
end;

function TForm1.OpenProcessByPID(PID: DWORD): THandle;
begin
  Result := OpenProcess(PROCESS_VM_WRITE or PROCESS_VM_READ or PROCESS_VM_OPERATION, False, PID);
end;

procedure TForm1.BtnApplyClick(Sender: TObject);
var
  Address1, Address2, Address3, Address4: Pointer;
  Buffer1, Buffer2, Buffer3, Buffer4: TBytes;
begin
  if FProcessHandle = 0 then
  begin
    ShowMessage('No process attached.');
    Exit;
  end;

  // Endereços para alteração
  Address1 := Pointer($00CC518C); // Substitua pelos endereços reais
  Address2 := Pointer($00CC5524);
  Address3 := Pointer($00CC5894);
  Address4 := Pointer($00CC568C);

  // Valores para escrever
  Buffer1 := TBytes.Create(Byte(StrToIntDef(EditValue1.Text, 0)));
  Buffer2 := TBytes.Create(Byte(StrToIntDef(EditValue2.Text, 0)));
  Buffer3 := TBytes.Create(Byte(StrToIntDef(EditValue3.Text, 0)));
  Buffer4 := TBytes.Create(Byte(StrToIntDef(EditValue4.Text, 0)));

  WriteMemory(Address1, Buffer1);
  WriteMemory(Address2, Buffer2);
  WriteMemory(Address3, Buffer3);
  WriteMemory(Address4, Buffer4);
end;

procedure TForm1.WriteMemory(Address: Pointer; const Buffer: TBytes);
var
  Written: SIZE_T;
begin
  if not WriteProcessMemory(FProcessHandle, Address, @Buffer[0], Length(Buffer), Written) then
    ShowMessage('Failed to write memory.');
end;

end.

